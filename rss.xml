<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>SAY something</title><link>http://sayuan.github.io/</link><description>Shiao-An Yuan personal blog</description><atom:link rel="self" href="http://sayuan.github.io/rss.xml" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Sat, 06 Jun 2015 17:01:56 GMT</lastBuildDate><generator>http://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>程式競賽小技巧 - Binary Search</title><link>http://sayuan.github.io/posts/binary-search.html</link><dc:creator>Shiao-An Yuan</dc:creator><description>&lt;div&gt;&lt;p&gt;最近在 &lt;a href="https://kaif.io"&gt;Kaif&lt;/a&gt; 開了一個 &lt;a href="https://kaif.io/z/programming-contest"&gt;程式競賽&lt;/a&gt; 區，打算在上面提一些我在競賽中學到的技巧，
不過既然我有一個很久沒動筆的 Blog，不如就直接寫在這裡，再把連結貼到 Kaif 吧。&lt;/p&gt;
&lt;p&gt;Binary Search 在程式競賽中，指的不是用來檢查元素在 sorted list 中位置的方法，
而是一種解題技巧。適用 Binary Search 的題目，通常會有兩個特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;目的是要求出某個變數 "滿足某個條件" 的最小值，
   且變數超出此值後也都會繼續滿足此條件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;無法使用有效率的方法計算出答案，但只要給變數任意的值，
   都能容易的判斷出是否滿足條件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在針對整數域時，我的 code 會像是這樣：&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;lower&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1000000&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;                    &lt;span class="c1"&gt;// 某個大到一定滿足條件的值&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;upper&lt;/span&gt;&lt;span class="o"&gt;)/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;satisfied&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;     &lt;span class="c1"&gt;// 將 mid 代入檢查是否滿足&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;satified&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;lower&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;離開 &lt;code&gt;while&lt;/code&gt; 迴圈時，&lt;code&gt;lower&lt;/code&gt; 會與 &lt;code&gt;upper&lt;/code&gt; 相等，並且就是所求答案。&lt;/p&gt;
&lt;p&gt;那麼在實數域會有什麼不同呢？這就是我覺得有意思的地方了。
由於浮點數精確度的關係，是有可能發生 &lt;code&gt;mid&lt;/code&gt; 等於 &lt;code&gt;lower&lt;/code&gt; 的情況，導致形成無窮迴圈。&lt;/p&gt;
&lt;p&gt;好在我們知道比較浮點數應該要允許一點誤差。通常我的習慣是加上一個常數
&lt;code&gt;Є&lt;/code&gt;，於是 code 會長這樣：&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;EPSILON&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;EPSILON&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;使用這個技巧，只要你選擇了 "適當" 的 &lt;code&gt;Є&lt;/code&gt;，程式就會是可以正確運行的。
但什麼情況下會出問題呢？&lt;/p&gt;
&lt;p&gt;當你的 &lt;code&gt;lower&lt;/code&gt; 很大，而 &lt;code&gt;Є&lt;/code&gt; 很小時，同樣有可能發生 &lt;code&gt;lower+EPSILON==lower&lt;/code&gt; 的情況。&lt;/p&gt;
&lt;p&gt;那有沒有更好的方法？看看以下的 code 吧。&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;lower&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;e30&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;times&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;times&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;times&lt;/span&gt;&lt;span class="o"&gt;++)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;      &lt;span class="c1"&gt;// 注意這行&lt;/span&gt;
    &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;upper&lt;/span&gt;&lt;span class="o"&gt;)/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;satisfied&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;check&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;satisfied&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;lower&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;結果就是什麼都不要管，固定跑個足夠次數就好。:p&lt;/p&gt;
&lt;p&gt;我自己習慣跑 50 次，但也看過其他參賽者使用 40, 100, 200 次。&lt;/p&gt;&lt;/div&gt;</description><category>algorithm</category><category>competitive programming</category><category>programming contest</category><guid>http://sayuan.github.io/posts/binary-search.html</guid><pubDate>Sat, 06 Jun 2015 15:33:28 GMT</pubDate></item><item><title>使用 Graphviz 繪製網路拓樸</title><link>http://sayuan.github.io/posts/network-topology-by-graphviz.html</link><dc:creator>Shiao-An Yuan</dc:creator><description>&lt;div&gt;&lt;p&gt;自從離開了 Android 產業之後，我加入了一間與網路服務相關的新創公司。
在工作內容上，經常會需要理解對方的網路環境，而解決這個問題最好的方法，
就是事先準備好一份網路拓樸並歸檔。&lt;/p&gt;
&lt;h3&gt;Requirements&lt;/h3&gt;
&lt;p&gt;因此，接下來的任務就是尋找一個適合我們的 Diagram Editor，以下是我們的需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;跨平台：公司內三種作業系統都有人使用，需要選擇一個各種平台上都能使用的檔案
   格式，開放格式尤佳。&lt;/li&gt;
&lt;li&gt;簡單：單就繪圖操作的部份，希望是連非技術人員也能夠使用。&lt;/li&gt;
&lt;li&gt;容易修改：當網路架構有些微變動時，希望能夠很容易的完成修改，不需要大量的微
   調各節點的位置。&lt;/li&gt;
&lt;li&gt;版本控制：不管是使用什麼格式，版本控制都是必要的，但 binary 檔案管理起來總
   是比較麻煩。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其實不難看出來，會列出這種需求，我根本就只是想內定 &lt;a href="http://www.graphviz.org/"&gt;Graphviz&lt;/a&gt; 嘛！確實如此，
但在 &lt;strong&gt;簡單&lt;/strong&gt; 這個項目上，Graphviz 卻似乎是最差的選擇，不把這個問題處理好，我看
大概很難順利將 Graphviz 導入公司。&lt;/p&gt;
&lt;p&gt;我們暫且先不論 Graphviz 是否足夠簡單，還是先把環境準備好，實際畫張圖來看看。&lt;/p&gt;
&lt;h3&gt;Installation&lt;/h3&gt;
&lt;p&gt;其實在我進行 &lt;del&gt;survey&lt;/del&gt; 內定之前，就已經先透過 Google 找了一遍，出乎意料
的只找到了一篇：&lt;a href="http://itsecworks.com/2012/03/16/networking-topology-with-graphviz/"&gt;Network topology with graphviz&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;不過有總比沒有好，試著依樣畫葫蘆跑一遍，結果卻是 &lt;code&gt;dot&lt;/code&gt; 執行時出現錯誤。查了才知
道，原來 Graphviz 到了版本 2.29 之後 &lt;code&gt;node&lt;/code&gt; 才開始支援 &lt;code&gt;image&lt;/code&gt; 屬性。但我所使用
的 Ubuntu 12.04 的套件庫中的版本只到 2.26，且一直到 14.04 才開始使用更新的版本。&lt;/p&gt;
&lt;p&gt;這種類似的事情遇多了，最簡單的方法就是找個現成的 &lt;code&gt;PPA&lt;/code&gt;，通常我會從官方維護的開始
找起，於是：&lt;/p&gt;
&lt;pre class="code literal-block"&gt;sudo apt-add-repository ppa:gviz-adm/graphviz-dev
&lt;/pre&gt;


&lt;p&gt;接著要安裝時，&lt;code&gt;apt&lt;/code&gt; 卻又出現錯誤：&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="n"&gt;graphviz&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Depends&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;libgraphviz4&lt;/span&gt; &lt;span class="o"&gt;(&amp;gt;=&lt;/span&gt; &lt;span class="mf"&gt;2.18&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;but&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;going&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;installed&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;好在 &lt;a href="http://askubuntu.com/"&gt;Ask Ubuntu&lt;/a&gt; 上早有&lt;a href="http://askubuntu.com/questions/196230/how-do-i-install-graphviz-2-29-in-12-04"&gt;解答&lt;/a&gt;，照著做即可：&lt;/p&gt;
&lt;pre class="code literal-block"&gt;sudo apt-get update
sudo apt-get remove libcdt4 libpathplan4
sudo apt-get install graphviz
&lt;/pre&gt;


&lt;h3&gt;Images&lt;/h3&gt;
&lt;p&gt;裝好新版本的 Graphviz 後，還需要用來表示各種節點的圖片，這裡我所選擇的是
&lt;a href="http://www.cisco.com/web/about/ac50/ac47/2.html"&gt;Cisco 免費提供的 icons&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Cisco 提供的圖片格式是 &lt;code&gt;JPEG&lt;/code&gt;，而根據 Graphviz 的文件，應該是有支援 &lt;code&gt;JPEG&lt;/code&gt;，
但不知道是哪裡出了問題，我並沒有辦法順利使用，所以我是自行轉成 &lt;code&gt;PNG&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;Results&lt;/h3&gt;
&lt;p&gt;最後的結果就是下圖：&lt;/p&gt;
&lt;p&gt;&lt;img alt="Topology" src="http://sayuan.github.io/galleries/misc/topology.png"&gt;&lt;/p&gt;
&lt;p&gt;而上圖對應的 dot 原始檔如下：&lt;/p&gt;
&lt;pre class="code literal-block"&gt;graph G {
    node [shape=none, height=1.2]
    rankdir=LR

    // Modems
    node [labelloc="b", image="icons/modem.png"] {
        "Modem 1"
        "Modem 2"
    }

    // Routers
    node [labelloc="b", image="icons/atm router.png"] {
        "Router"
    }

    // Switches
    node [labelloc="b", image="icons/atm switch.png"] {
        "Switch"
    }

    // Access Points
    node [labelloc="b", image="icons/wireless router.png"] {
        "AP 1"
        "AP 2"
    }

    // Sub-networks
    node [labelloc="c", image="icons/cloud.png"] {
        "WAN"
    }

    // Relationships
    "WAN" -- {"Modem 1", "Modem 2"} {
        {"Modem 1", "Modem 2"} -- "Router" {
            "Router" -- "Switch" {
                "Switch" -- {"AP 1", "AP 2"}
            }
        }
    }
}
&lt;/pre&gt;


&lt;p&gt;如果是曾經接觸過 &lt;code&gt;dot&lt;/code&gt; 的讀者，或許會覺得我所使用的語法很怪異，因為原始碼中的
那些大括號與縮排，在 &lt;code&gt;dot&lt;/code&gt; 語言中其實是完全沒有作用的，我這樣寫的目的，純粹是
想降低使用 Graphviz 繪製網路拓樸的學習難度。以下是我的一些考量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;將 &lt;strong&gt;宣告&lt;/strong&gt; 與 &lt;strong&gt;建立關聯&lt;/strong&gt; 的部份完全區分開，規定關聯一定要寫在最後面。&lt;/li&gt;
&lt;li&gt;將節點宣告的概念，由原先的 &lt;strong&gt;修改後續 node 的 default attributes&lt;/strong&gt;，
   變成簡單的 &lt;strong&gt;集合中的元素&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;由於我們所需要繪製的網路圖只會是樹狀結構，使用縮排可以更方便閱讀。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;我們實際的使用方式是將網路拓樸紀錄在 Redmine 的 wiki 內，
而&lt;a href="https://github.com/tckz/redmine-wiki_graphviz_plugin"&gt;這裡有一個 plugin&lt;/a&gt;，能夠直接將 wiki 中的純文字的 dot，在預覽和儲存後直接以
轉換後的圖片顯示，實在是方常方便。&lt;/p&gt;
&lt;p&gt;然而使用 Graphviz 有其極限，對於複雜的網路拓樸，或著對美觀極度要求時，使用其他
的軟體搭配仍然有其必要。&lt;/p&gt;&lt;/div&gt;</description><category>Dot</category><category>Graphviz</category><category>Network</category><guid>http://sayuan.github.io/posts/network-topology-by-graphviz.html</guid><pubDate>Sun, 23 Feb 2014 14:02:59 GMT</pubDate></item><item><title>Android Java 層 Debug 工具介紹 (2)</title><link>http://sayuan.github.io/posts/android-java-debugging-2.html</link><dc:creator>Shiao-An Yuan</dc:creator><description>&lt;div&gt;&lt;p&gt;在系列文的&lt;a href="http://sayuan.github.io/posts/android-java-debugging-1.html"&gt;第一篇文章&lt;/a&gt;中，我已經介紹過 Log Viewer 與
Profiler，而這次所要介紹的內容則是 Debugger，以及一些 Reverse Engineering 工具。
那麼，就先從 Debugger 開始吧。&lt;/p&gt;
&lt;h3&gt;Remote Debugging&lt;/h3&gt;
&lt;p&gt;對於 Android App 開發者來說，在 Android 上 debug 是在自然不過的事了。
您只需要準備好專案，點一下 &lt;code&gt;Debug&lt;/code&gt; 按鈕，IDE 就自動進入 debug 模式，接著無論是
下中斷點、單步執行，或是查看變數內容……等，一切皆任君差遣，但……&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果不是透過 IDE 啟動的程式執行到一半，出現了預期之外的狀況，這時您還能不
   能透過 Debugger 進行 debug 呢？&lt;/li&gt;
&lt;li&gt;若是執行的程式沒有建立專案，甚至沒有 Source Code 時，Debugger 還能有所作為嗎？&lt;/li&gt;
&lt;li&gt;又或著是系統廠 RD 最想要的功能，能不能對系統 Service 進行 debug？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述三個問題的答案都是 YES，當然其中也會有一些前提必須滿足，像是 debug 的對象必
須具有 debuggable flag，或著手機本身 image 為 Engineer build。在前一篇文章中我也
提過了，不需要太擔心這個條件無法滿足，因為下一個章節就會來解決這件事。:)&lt;/p&gt;
&lt;p&gt;我在這裡所要介紹的技巧，其實就和對 App 進行 debug 本質上是一樣的，只不過操作的
過程比較手動一些。我會以 Eclipse 進行以下的示範，但其實使用任何一款支援 Remote
Debugging 的 debugger 皆可，甚至連 Android plugin 都不需要安裝。&lt;/p&gt;
&lt;h4&gt;1. Select debug port&lt;/h4&gt;
&lt;p&gt;&lt;img alt="Select debug port" src="http://sayuan.github.io/galleries/android-java-debug/debug_port.png" title="caption test"&gt;&lt;/p&gt;
&lt;p&gt;首先到任何一個看得見這畫面的地方，不管是 Eclipse 內建的 DDMS 也好，或著獨立的
Android Device Monitor 也好，總之只要是這個畫面都好。&lt;/p&gt;
&lt;p&gt;對著想要進行 debug 的 process 點一下。在點選之前，最後一欄的文字本來會是 &lt;code&gt;8600&lt;/code&gt;
之類，但點選之後就會變成 &lt;code&gt;8600 / 8700&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;這些數字是其實是 Port Frowarding 所開在本機的 port，透過這些 port，就可以和手機
內特定 process 對應的 JVM 進行溝通。&lt;/p&gt;
&lt;p&gt;在點選之前的 port 是以流水號方式從 8600 開始編號，而只要是被選取的 process
就會額外準備一組 port 8700。因為數字是固定的，因此在後續設定 debugger 時會比較方
便，所以這個步驟其實並不是必要的。&lt;/p&gt;
&lt;h4&gt;2. Create debug configure&lt;/h4&gt;
&lt;p&gt;&lt;img alt="Create debug configure" src="http://sayuan.github.io/galleries/android-java-debug/debug_config.png"&gt;&lt;/p&gt;
&lt;p&gt;接下來，在 &lt;code&gt;Debug Configurations&lt;/code&gt; 中建立一個新的 &lt;code&gt;Remote Java Application&lt;/code&gt;，
右邊的 &lt;code&gt;Project&lt;/code&gt; 則視您 debug 的對象選擇，若是沒有對應的專案則請保持空白，
&lt;code&gt;Port&lt;/code&gt; 則填上在前一步驟看到的數字。因為所有我打算進行 debug 的 process 都會事先
被我設定好 port 8700，因此我只需要準備一個 Debug Configuration 即可。&lt;/p&gt;
&lt;p&gt;最後按下 &lt;code&gt;Debug&lt;/code&gt; 按鈕，順利的話就能看到 debugger 成功 attach，可以開始 debug
了！&lt;/p&gt;
&lt;h4&gt;3. Start debugging!&lt;/h4&gt;
&lt;p&gt;如果您所 debug 的 App 在 Eclipse 中有對應的專案，相信接下來該怎麼做已經不需要
多說明了，開啟想 debug 的 source code、設好中斷點，接著等程式執行到該部份就好。&lt;/p&gt;
&lt;p&gt;但如果是沒有專案的 App，因為 IDE 不知道要去哪裡找 source code，就算您自己開好了
對應的程式碼並試圖在上面建立中斷點，也壓根不會有作用。&lt;/p&gt;
&lt;p&gt;現在請回到前一張圖，注意到視窗右半邊共有三個分頁，其中第二個分頁 &lt;code&gt;Source&lt;/code&gt; 就是我
們要找的答案！&lt;/p&gt;
&lt;p&gt;&lt;img alt="Add source" src="http://sayuan.github.io/galleries/android-java-debug/add_source.png"&gt;&lt;/p&gt;
&lt;p&gt;將所有需要用到的 source code 的 &lt;code&gt;root&lt;/code&gt; 都用 &lt;code&gt;File System Directory&lt;/code&gt; 加入後，您就
可以正常的建立中斷點，並隨著 debugger 在程式碼間遨遊了。若以 Android Framework
為例，您所需要加入的路徑大概會是 &lt;code&gt;.../android/frameworks/base/core/java&lt;/code&gt;。
除此之外我還會移除掉原先的 &lt;code&gt;Default&lt;/code&gt;，因為這裡面都是 Java 的 Library，而 Android
裡頭用的則完全是另一套，雖然提供的 API 大同小異，但實作完全不一樣，這樣是沒辦法顯
示正確對應的 source code 的。&lt;/p&gt;
&lt;p&gt;若是連 source code 都沒有，其實您還是可以暫停 thread、觀察變數、單步執行，但是這
樣能做甚麼？別急，看完下一個章節就知道了。&lt;/p&gt;
&lt;h3&gt;Reverse Engineering&lt;/h3&gt;
&lt;h4&gt;dex2jar&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://code.google.com/p/dex2jar/"&gt;dex2jar&lt;/a&gt; 是一套將 dalvik bytecode 轉成 java bytecode 的工具，雖然轉換後的檔案
並沒有因此就變得較好讀，但早就有現成的 Java decompiler 可以搭配使用，例如
&lt;a href="http://jd.benow.ca/#jd-gui"&gt;JD-GUI&lt;/a&gt; 就是一個常見的搭配。&lt;/p&gt;
&lt;p&gt;dex2jar 的執行方式非常的簡單，直接吃 apk 即可：&lt;/p&gt;
&lt;pre class="code literal-block"&gt;dex2jar.sh CtsVerifier.apk
&lt;/pre&gt;


&lt;p&gt;產生的檔案是 &lt;code&gt;CtsVerifier_dex2jar.jar&lt;/code&gt;，接著用 &lt;code&gt;jd-gui&lt;/code&gt; 開啟：&lt;/p&gt;
&lt;pre class="code literal-block"&gt;jd-gui CtsVerifier_dex2jar.jar
&lt;/pre&gt;


&lt;p&gt;&lt;img alt="jd-gui" src="http://sayuan.github.io/galleries/android-java-debug/jd-gui.png"&gt;&lt;/p&gt;
&lt;p&gt;不過不是每一次都能像上圖這樣順利，經常會遇到 decompile 的結果不正常的狀況。
這時候也許您可以考慮換一套 decompiler 試試，像 &lt;a href="http://varaneckas.com/jad/"&gt;JAD&lt;/a&gt; 就是另一個常見的選擇。
這幾天我也剛好在 &lt;a href="http://androidcracking.blogspot.tw/2014/02/zerdeis-luyten-worthwhile-jd-gui.html"&gt;android cracking&lt;/a&gt; 上看到另一套工具 &lt;a href="https://github.com/deathmarine/Luyten/"&gt;Luyten&lt;/a&gt;，聽說效果比
JD-GUI 更好。&lt;/p&gt;
&lt;p&gt;不管如何，遇到需要 reverse engineering 時，先搬 dex2jar 出來，也許就已經足夠了。
但若是遇到應付不了的情形，或許這時候就該呼叫 apktool 了。&lt;/p&gt;
&lt;h4&gt;apktool&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://code.google.com/p/android-apktool/"&gt;apktool&lt;/a&gt; 是一個 &lt;code&gt;decode&lt;/code&gt; / &lt;code&gt;rebuild&lt;/code&gt; apk 的工具，將 apk 解開後的目錄結構如下：&lt;/p&gt;
&lt;pre class="code literal-block"&gt;AndroidManifest.xml
apktool.yml
assets
lib
res
smali
&lt;/pre&gt;


&lt;p&gt;前面提了好幾次的 debuggable flag 就在 AndroidManifest.xml 裡，開啟 debuggable
後 rebuild 並安裝至手機內，先前說過的工具就全部都能使用了。&lt;/p&gt;
&lt;h5&gt;smali&lt;/h5&gt;
&lt;p&gt;接下來請注意到 smali 這個資料夾，這裡存的是利用 &lt;a href="https://code.google.com/p/smali/"&gt;smali&lt;/a&gt; 這套工具將
dalvik bytecode 反組譯之後的結果。&lt;/p&gt;
&lt;p&gt;smali 這名字取得很有趣，是冰島語的 &lt;code&gt;assembler&lt;/code&gt;。為什麼選冰島語？因為 &lt;code&gt;dalvik&lt;/code&gt;
是冰島的一個鎮的名字。&lt;/p&gt;
&lt;p&gt;smali 的語法源自於 &lt;a href="http://jasmin.sourceforge.net/"&gt;jasmin&lt;/a&gt;，並將指令替換為 Android 上所用的
&lt;a href="http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html"&gt;Dalvik opcodes&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;關於 smali 細節語法的說明，似乎不適合繼續寫在這篇文章內了，因此我這裡就貼一小段
source code 與實際產生的 smali 做對照，供各位做參考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;source code (截取自 CtsVerifier)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="code literal-block"&gt;    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TestListItem&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;mRows&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;notifyDataSetChanged&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;


&lt;ul&gt;
&lt;li&gt;smali&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="c"&gt;# virtual methods&lt;/span&gt;
&lt;span class="k"&gt;.method&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;L&lt;/span&gt;com/android/cts/verifier/&lt;span class="nc"&gt;TestListAdapter$TestListItem&lt;/span&gt;;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="kt"&gt;V&lt;/span&gt;    &lt;span class="c"&gt;# 回傳值為 void&lt;/span&gt;
&lt;span class="k"&gt;    .locals&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;   &lt;span class="c"&gt;# 除了參數以外只有一個變數，即 v0&lt;/span&gt;
&lt;span class="k"&gt;    .parameter&lt;/span&gt; &lt;span class="s"&gt;"item"&lt;/span&gt;

&lt;span class="k"&gt;    .prologue&lt;/span&gt;
&lt;span class="k"&gt;    .line&lt;/span&gt; &lt;span class="mi"&gt;37&lt;/span&gt;    &lt;span class="c"&gt;# 對應的 source code 行號&lt;/span&gt;
    iget-object &lt;span class="nb"&gt;v0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;p0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;L&lt;/span&gt;com/android/cts/verifier/&lt;span class="nc"&gt;ArrayTestListAdapter&lt;/span&gt;;&lt;span class="p"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;mRows&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;L&lt;/span&gt;java/util/&lt;span class="nc"&gt;List&lt;/span&gt;;

    invoke-interface &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nb"&gt;v0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="kt"&gt;L&lt;/span&gt;java/util/&lt;span class="nc"&gt;List&lt;/span&gt;;&lt;span class="p"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nf"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;L&lt;/span&gt;java/lang/&lt;span class="nc"&gt;Object&lt;/span&gt;;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="kt"&gt;Z&lt;/span&gt;

&lt;span class="k"&gt;    .line&lt;/span&gt; &lt;span class="mi"&gt;38&lt;/span&gt;    &lt;span class="c"&gt;# p0=this, p1=item&lt;/span&gt;
    invoke-virtual &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nb"&gt;p0&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="kt"&gt;L&lt;/span&gt;com/android/cts/verifier/&lt;span class="nc"&gt;ArrayTestListAdapter&lt;/span&gt;;&lt;span class="p"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nf"&gt;notifyDataSetChanged&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="kt"&gt;V&lt;/span&gt;

&lt;span class="k"&gt;    .line&lt;/span&gt; &lt;span class="mi"&gt;39&lt;/span&gt;
    return-void
&lt;span class="k"&gt;.end method&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;smali 的語法其實並不難，因此在理解之後，少量的修改程式邏輯或著安插其他程式碼，
也都不會是什麼困難的事了。&lt;/p&gt;
&lt;h3&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;這次兩篇文章共介紹了四種類型的工具，說明一下我使用各種工具的時機：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Log viewer&lt;ul&gt;
&lt;li&gt;尋找問題發生點&lt;/li&gt;
&lt;li&gt;了解流程，除了訊息本身以外，也很容易藉由文字找出對應的程式位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Profiler&lt;ul&gt;
&lt;li&gt;找出程式瓶頸與需要最佳化的位置&lt;/li&gt;
&lt;li&gt;畫 call graph 幫助了解執行流程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Debugger&lt;ul&gt;
&lt;li&gt;觀察各 thread 的 method stack 與變數內容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reverse Engineering tools&lt;ul&gt;
&lt;li&gt;不得已沒有 source code 的時候才用 XD&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description><category>Android</category><category>apktool</category><category>debugging</category><category>Eclipse</category><guid>http://sayuan.github.io/posts/android-java-debugging-2.html</guid><pubDate>Fri, 14 Feb 2014 18:22:56 GMT</pubDate></item><item><title>Android Java 層 Debug 工具介紹 (1)</title><link>http://sayuan.github.io/posts/android-java-debugging-1.html</link><dc:creator>Shiao-An Yuan</dc:creator><description>&lt;div&gt;&lt;p&gt;今天又從硬碟裡翻出一份還在前公司時製作的內訓資料，是當時所有我會的 Android Java
debug 工具的介紹，於是整理之後就成為了現在這篇文章。&lt;/p&gt;
&lt;p&gt;本文中提及的工具與使用方法我都已測試過，即使在目前在最新的 Android 4.4
上也還能正常使用，但畢竟這些已經是一年前的資料了，或許已經有更新的工具能替代
使用，因此若是您知道其他更好用的工具，也希望您能不吝指出。:)&lt;/p&gt;
&lt;h3&gt;Log Viewer&lt;/h3&gt;
&lt;p&gt;老實說我從來就不覺得 &lt;code&gt;ADT&lt;/code&gt; 附的 Log Viewer 好用，身為 command line
魔人，當然要選擇 command line 的作法。&lt;/p&gt;
&lt;h4&gt;Colored Logcat&lt;/h4&gt;
&lt;p&gt;雖然 &lt;code&gt;adb&lt;/code&gt; 本身就有 &lt;code&gt;logcat&lt;/code&gt; 指令，但既沒有對齊欄位，也沒有顏色識別，實在是
不容易從中識別出自己所關心的 log，好在早就有現成的 &lt;a href="http://jsharkey.org/blog/2009/04/22/modifying-the-android-logcat-stream-for-full-color-debugging/"&gt;Colored Logcat&lt;/a&gt;。&lt;code&gt;Colored
Logcat&lt;/code&gt; 是由 &lt;a href="http://jsharkey.org"&gt;Jeff Sharkey&lt;/a&gt; 所開發的一個以 python 寫成，用來 parsing &lt;code&gt;adb
logcat&lt;/code&gt; 的輸出，並加上顏色與對齊後輸出的工具。&lt;/p&gt;
&lt;p&gt;&lt;img alt="coloredlogcat" src="http://sayuan.github.io/galleries/android-java-debug/colorcat.png"&gt;&lt;/p&gt;
&lt;p&gt;由於原作者釋出 &lt;code&gt;Colored Logcat&lt;/code&gt; 之後沒有持續維護，因此在 Github 及 Google Code
上都可以找到其他人的分支。我自己所使用的版本則是對其做了兩個修改：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;增加 -v 參數使其可顯示每一筆 log 的時間&lt;/li&gt;
&lt;li&gt;補上原實作漏了的 log 層級：FATAL&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;或許有人會問，這種工具怎麼看都還是比不上 &lt;code&gt;ADT&lt;/code&gt; 內建的 Log Viewer 呀，究竟
command line 有何神奇魔力？這些工具單獨使用的話確實是不怎麼樣，但厲害的地方在於
它們可以很輕鬆的搭配其他 shell 指令而組合出更多彈性的功能，例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;搭配 grep 以過濾關鍵字&lt;/li&gt;
&lt;li&gt;將輸出 redirect (或 tee) 至檔案，方便後續處理&lt;/li&gt;
&lt;li&gt;如果有使用 screen, tmux，還可以隨時暫停，並在畫面上搜尋關鍵字&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Debug function&lt;/h4&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;debug&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;StackTraceElement&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentThread&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getStackTrace&lt;/span&gt;&lt;span class="o"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;className&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getClassName&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;className&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;className&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;substring&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;className&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;lastIndexOf&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'.'&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;android&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;util&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;Log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;v&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"_DEBUG_"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getLineNumber&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;": "&lt;/span&gt;
            &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;className&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;"."&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMethodName&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;" "&lt;/span&gt;
            &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;util&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;Arrays&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;deepToString&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;這個其實既不是 Log Viewer，也不能算是 debug tool，勉強只能算是個小技巧吧。
它的功用是在顯示的 log 前面加上 class name, method name 與行數，就像是 C 的
&lt;code&gt;__FILE__&lt;/code&gt;, &lt;code&gt;__LINE__&lt;/code&gt; 與 &lt;code&gt;__func__&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;由於參數 &lt;code&gt;arr&lt;/code&gt; 使用了 Java 5.0 開始才有的 &lt;code&gt;Autoboxing&lt;/code&gt; 與
&lt;code&gt;Varargs&lt;/code&gt;，因此無論是什麼參數、幾個參數都能接受，而輸出的部份又用了
deepToString，所以連陣列內容都能印出。&lt;/p&gt;
&lt;p&gt;這個 method 其實不只能在 Android 上使用，一般的 Java
環境下也能運作，但需要將第二行中的常數 &lt;code&gt;3&lt;/code&gt; 改為 &lt;code&gt;2&lt;/code&gt; 才行。&lt;/p&gt;
&lt;h3&gt;Profiler&lt;/h3&gt;
&lt;p&gt;接下來這個 profiler 其實只是 &lt;code&gt;ADT&lt;/code&gt; 內建的工具，官方也有一篇詳細
的&lt;a href="http://developer.android.com/tools/debugging/debugging-tracing.html"&gt;教學&lt;/a&gt;，所以我就只以圖片與簡短描述帶過。&lt;/p&gt;
&lt;p&gt;執行 profiler 共有兩種方式，第一種方式是在程式中安插程式碼：&lt;/p&gt;
&lt;h4&gt;第一種&lt;/h4&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="c1"&gt;// start tracing to "/sdcard/calc.trace"&lt;/span&gt;
&lt;span class="n"&gt;Debug&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;startMethodTracing&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"calc"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// 做 profiling 的區域&lt;/span&gt;

&lt;span class="c1"&gt;// stop tracing&lt;/span&gt;
&lt;span class="n"&gt;Debug&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;stopMethodTracing&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;上述這個方法比較麻煩，但能確保 profiling 的對象只有自己關心的區域。&lt;/p&gt;
&lt;h4&gt;第二種&lt;/h4&gt;
&lt;p&gt;&lt;img alt="Start Profiling" src="http://sayuan.github.io/galleries/android-java-debug/start_profiling.png"&gt;&lt;/p&gt;
&lt;p&gt;第二個方法則是直接在 Android Device Monitor 工具內，選好要 profiling 的
process，然後點上圖中被藍色圓圈圈起的按鈕，並在打算停止 profiling
時再按一下即可。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Traceview" src="http://sayuan.github.io/galleries/android-java-debug/traceview.png"&gt;&lt;/p&gt;
&lt;p&gt;接著畫面上就會出現 profiling 的結果。&lt;/p&gt;
&lt;h4&gt;Call Graph&lt;/h4&gt;
&lt;p&gt;第一種方法執行完的 trace file 會存在 SD card 內，而第二種則是存在
&lt;code&gt;/tmp/ddms....&lt;/code&gt;，可以從分頁名稱上得到確切的檔名。&lt;/p&gt;
&lt;p&gt;有了 trace file，接著只要執行：&lt;/p&gt;
&lt;pre class="code literal-block"&gt;dmtracedump -g callgraph.png calc.trace
&lt;/pre&gt;


&lt;p&gt;就可以得到如下的 call graph。&lt;/p&gt;
&lt;p&gt;&lt;img alt="Call Graph" src="http://sayuan.github.io/galleries/android-java-debug/callgraph.png"&gt;&lt;/p&gt;
&lt;h4&gt;debuggable flag&lt;/h4&gt;
&lt;p&gt;第二種方法在使用上有個限制，即操作的手機必須是 Engineering build，或著所觀察的
App 具有 debuggable flag。&lt;/p&gt;
&lt;p&gt;不過即使兩像條件都不具備也不用擔心，您還是可以用後續文章將會提到的 reverse
engineering tool: &lt;code&gt;apktool&lt;/code&gt;，將原本的 apk 檔解開、加上 debuggable
flag、重新包裝回 apk 檔，然後就能開心的使用了。運用這種重新打包的手法，就算沒有
source code，也能將所需的 code 插入，因此正好可以拿來安插第一種 profiling
所需的 code，細節將會在後續的文章中說明。&lt;/p&gt;
&lt;p&gt;篇幅好像差不多了，那麼就先在此打住吧。
接下來預計還會寫一至兩篇文章介紹 remote debugging 與 reverse engineering
tool，希望我能早日完成。:)&lt;/p&gt;&lt;/div&gt;</description><category>Android</category><category>coloredlogcat</category><category>debugging</category><category>traceview</category><guid>http://sayuan.github.io/posts/android-java-debugging-1.html</guid><pubDate>Sun, 09 Feb 2014 12:36:56 GMT</pubDate></item><item><title>Android CTS - 讓 Report 說話</title><link>http://sayuan.github.io/posts/android-cts-report.html</link><dc:creator>Shiao-An Yuan</dc:creator><description>&lt;div&gt;&lt;p&gt;接著來談談當初在負責 CTS 時遇到的最大困難，以及最後解決的方法。&lt;/p&gt;
&lt;h3&gt;什麼是 CTS？&lt;/h3&gt;
&lt;p&gt;Android 雖然是 Open Source Project，即任何的廠商都可以自行生產手機，但
如果想在出廠時內建 Google Play 等 Google 所提供的 APP，就必須與 Google
簽合約，即每一款生產的手機都需要通過 CTS 測試。&lt;/p&gt;
&lt;p&gt;CTS 測試包含上萬筆測項，能否順利通過將影響手機是否能正式出貨，因此對各系
統廠而言，這都會是一個相當重要的任務。通過 CTS 的方式，是由廠商自行執行
Google 提供的 CTS 程式，並產生一份通過所有測試的 Report，Google 審核無誤
後，這樣就算大功告成了。&lt;/p&gt;
&lt;p&gt;然而，即使是同一款手機，每一次執行 CTS 都不見得能得到完全相同的結果。這
部份有可能是手機本身的軟、硬體不穩定，也有可能是來自於 CTS 的 bug。&lt;/p&gt;
&lt;h3&gt;困難點&lt;/h3&gt;
&lt;p&gt;由於每次執行 CTS 得到的結果都不同，而只要成功產生一次全部通過的 Report
就可以提交，那麼是不是可以準備很多台電腦、很多台手機，每天二十四小時的跑
，只要任何一次 ALL PASS 就好？&lt;/p&gt;
&lt;p&gt;是的，這樣確實沒有問題。於是公司安排了一部分的測試人力負責運行 CTS，早期
是一天產出一份，後來不知道怎麼搞的，變成兩組人馬在做，有時候一天會產生近
十份報表。&lt;/p&gt;
&lt;p&gt;如果是問題已經被解決的差不多的階段，這樣做確實很合理；但如果有些測試尚未
被解決，百分百會失敗，這樣做就不是很有意義了。而每一份報告送來給我時，通
常還會附上測試者自己的觀察，例如：「某個測試最近失敗的機率好像變高了」、
「同個型號的 A 手機一直失敗、但 B 手機就沒問題」、「晚上再開始跑好像比較
容易成功」。這些猜測有時正確、有時錯誤，然而因為 Report 實在太多，我也實
在沒辦法從中學到什麼。&lt;strong&gt;於是這些數不清的 Report，消耗了大量的人力與資源
，卻什麼忙也沒幫上。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;突破口&lt;/h3&gt;
&lt;p&gt;其實不難發覺，關鍵就在這些 Report 上。大部分需要的資訊，這些 Report 上都
有，只是太多了、太零散了，沒有辦法馬上調出我需要的資訊，例如：「X 測項最
近一週的失敗率是否比上週高」、「A 測試者跑 Y 測項時是否比較容易失敗」？&lt;/p&gt;
&lt;p&gt;而解決的方法也就更簡單了，我花了三天時間寫了一個網頁，提供一個界面讓測試
者上傳 Report。程式收到 Report 後，就會擷取所有重要資訊，包含手機名稱與
識別碼、測試者的名字、執行時間和所有發生失敗的測試，並將這些資料統統丟進
資料庫。&lt;/p&gt;
&lt;p&gt;突然之間，所有的問題都獲得了解答。我們利用這個方式發現各家電信業者在執行
&lt;a href="https://github.com/sayuan/Android-CTS-notes/wiki/android.telephony.cts.SmsManagerTest#wiki-testsendmessages"&gt;傳簡訊相關的測試&lt;/a&gt;的成功率，從此規定以後都用成功率最高的業者的 SIM 卡
；也發現了某測試者因為操作不正確，所以他所負責的報告經常會有額外的狀況。&lt;/p&gt;
&lt;h3&gt;所以，重點是？&lt;/h3&gt;
&lt;p&gt;其實重點就是，我要把這支程式的關鍵部份放出來。&lt;a href="https://gist.github.com/sayuan/9d8611179405989d502c"&gt;gist 連接在此&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;至於為什麼不放整個網站出來？單純只是因為我的前端寫太爛，不好意思放出來讓
大家見笑。事實上，這個網站其實非常的簡單，甚至我放出的部份也沒有任何難度
，只是單純的 parsing XML 並存進資料庫而已，真要說有難度的地方，也只是
parsing 時比較費工而已。所以我放出 parsing 的部份，希望有需要的人可以在
略做修改的情況下就能夠使用，如果在使用上有遭遇什麼困難，也歡迎與我聯繫。&lt;/p&gt;&lt;/div&gt;</description><category>Android</category><category>CTS</category><guid>http://sayuan.github.io/posts/android-cts-report.html</guid><pubDate>Sun, 02 Feb 2014 15:37:47 GMT</pubDate></item><item><title>Android CTS 筆記</title><link>http://sayuan.github.io/posts/android-cts.html</link><dc:creator>Shiao-An Yuan</dc:creator><description>&lt;div&gt;&lt;p&gt;我過去曾經在國內的二線 Android 系統廠服務了約一年半的時間，當時所負責的
工作之一，就是負責處理 Android CTS 問題。雖然不是所有的 Issue 都由我負責
到底，但第一關的釐清、分配，和解決最後無明確歸屬的 Issue，都是我的任務。
而這一年多來追蹤過的 CTS 問題少說也有百項，也因此累積了不少的筆記。&lt;/p&gt;
&lt;p&gt;2013 年初我離職之後，這些筆記就一直塵封在我的硬碟至今。多虧了最近的年假
，心血來潮花了整整一天的時間，終於有機會讓這些筆記重見天日。我把它們全部
都重寫成 markdown 格式，並且上傳至 Github 的 wiki，連結就在&lt;a href="https://github.com/sayuan/Android-CTS-notes"&gt;這裡&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;希望這些資訊能給還在和 CTS 奮鬥的工程師們一些幫助，如果其中有任何錯誤與
不足的部份，還請不吝指出或著直接進行修正。&lt;/p&gt;&lt;/div&gt;</description><category>Android</category><category>CTS</category><guid>http://sayuan.github.io/posts/android-cts.html</guid><pubDate>Sun, 02 Feb 2014 11:25:16 GMT</pubDate></item><item><title>ydict - node.js 實作</title><link>http://sayuan.github.io/posts/ydict.html</link><dc:creator>Shiao-An Yuan</dc:creator><description>&lt;div&gt;&lt;h3&gt;What is "ydict"&lt;/h3&gt;
&lt;p&gt;身為一名 command line 魔人，儘可能的將所有在電腦上的操作在 command line
之內完成，是一件理所當然的事情，就連查字典也不例外，而 ydict
就是這樣的工具。&lt;/p&gt;
&lt;p&gt;&lt;img alt="ydict" src="http://sayuan.github.io/galleries/misc/ydict.png"&gt;&lt;/p&gt;
&lt;p&gt;ydict 的資料來自於 &lt;a href="http://tw.dictionary.yahoo.com/"&gt;Yahoo 字典&lt;/a&gt;，事實上 ydict
所作的事情就只是以使用者的輸入詞在 Yahoo 字典上查詢，然後 parsing
出重要的資訊，並以適合 terminal 的格式顯示在螢幕上。&lt;/p&gt;
&lt;p&gt;但其實 ydict 並不是 "一個" 工具，事實上很多人都曾開發自己的實作，
而各實作也有各自的分支，我現在已經找不出最早是由誰開發的了。
在眾多版本之中，我使用了最長時間的是 &lt;a href="https://github.com/freehaha/ydict"&gt;freehaha 實作的 Python 版本&lt;/a&gt;，
其次則是 &lt;a href="http://fourdollars.blogspot.tw/2008/05/vim-ydict.html"&gt;FourDollars 的 Perl 版本&lt;/a&gt;，在此先向兩位作者致上感謝。&lt;/p&gt;
&lt;h3&gt;My works&lt;/h3&gt;
&lt;p&gt;使用 ydict 這工具對我來說已經到了不可或缺的地步，但幾乎每隔一段時間 Yahoo
字典就會改版，而接下來的幾天在作者尚未更新之前，我就會沒有 ydict 可使用。
而另一方面，我也會希望能針對自己的需求，對 ydict 進行修改。&lt;/p&gt;
&lt;p&gt;我也確實試過自己動手修改，但後續要繼續與原作者的版本接軌卻反而成了一件麻煩事。
而在先前嘗試修改的經驗裡，我覺得必須要有容易更新的 parsing 規則，才能夠快速的針對
Yahoo 字典的改版做出更新。正巧最近我剛學了一點 JavaScript 與
node.js，我想如果能像 jQuery 一樣使用 CSS selector 進行
parsing，事情也許會簡單很多，於是 &lt;a href="https://github.com/sayuan/ydict.js/"&gt;ydict.js&lt;/a&gt; 就此誕生。&lt;/p&gt;
&lt;p&gt;ydict.js 的一個主要設計考量是，parsing 與 display
必須分離，parsing 的部份只會回傳處理後的 json，而 display 只是單純的將 josn
檔依照格式顯示在螢幕上， 因此在任何一方修改都不會影響到另一方。
另外我也把 parsing 的部份包成 module，讓其他 project
可以直接引用，雖然我覺得這個功能完全只是雞肋。:p&lt;/p&gt;
&lt;p&gt;此外，我也已經將 ydict.js 上傳 npm，因此只要執行下述指令即可完成安裝，
希望各位會喜歡。&lt;/p&gt;
&lt;pre class="code literal-block"&gt;[sudo] npm install -g ydict.js
&lt;/pre&gt;


&lt;h3&gt;What else?&lt;/h3&gt;
&lt;p&gt;我的好友 Andrew 與 Jeff 也和我一樣依賴 ydict，因此在去年 Yahoo
字典改版，各家實作卻都尚未支援之前，他們也都各自開發了自己的實作。&lt;/p&gt;
&lt;p&gt;首先是 &lt;a href="https://github.com/yongjhih/rc/blob/master/bin/andict"&gt;Andrew 的 shell script 版&lt;/a&gt;，使用 w3m 的超簡短作弊寫法，
麻雀雖小卻是五臟俱全。(&lt;strong&gt;使用前請先安裝 w3m 套件。&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;另外就是 &lt;a href="https://github.com/JeffChien/jydict"&gt;Jeff 開發的 LiveScript 版&lt;/a&gt;，和 ydict.js 一樣使用 &lt;a href="https://github.com/MatthewMueller/cheerio"&gt;cheerio&lt;/a&gt;
來處理 parsing，並且同樣也已經上傳 npm，因此只要執行下述指令即可安裝：&lt;/p&gt;
&lt;pre class="code literal-block"&gt;[sudo] npm install -g jydict
&lt;/pre&gt;&lt;/div&gt;</description><category>node.js</category><category>ydict</category><guid>http://sayuan.github.io/posts/ydict.html</guid><pubDate>Thu, 30 Jan 2014 07:07:52 GMT</pubDate></item><item><title>終於，新居落成</title><link>http://sayuan.github.io/posts/finally-my-new-blog.html</link><dc:creator>Shiao-An Yuan</dc:creator><description>&lt;div&gt;&lt;h3&gt;塵埃落定&lt;/h3&gt;
&lt;p&gt;嚷著說要寫 blog 也差不多拖了一、兩年了，除了單純的因為我懶以外，找不到合適的
static blog generator 也是一大主因。為了讓 blog
能完全在自己的掌控之中，我必須選一個自己看得懂、改得動的語言所實作的
generator，因此我首先關注的是以 Python 實作的 &lt;a href="http://blog.getpelican.com/"&gt;Pelican&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;確認了 Pelican 有所有我需要的功能：支援 markdown 語法、能夠顯示 LaTex
語法、syntax highlight 當然也是必要的，還有其他 blog 必備的 tag, RSS, ……等等。
然後最後是，選一個看得順眼的 theme ……。糟糕，怎麼找不到合適的？&lt;/p&gt;
&lt;p&gt;我這個人除了懶以外，另一個缺點是龜毛，而且常常是龜毛在我沒有能力做得更好的地方。
我開始嘗試改寫 theme，當然沒有美術細胞的我，即使投入了不少時間，
卻仍然做不出能看的東西，間接導致我的部落格生涯遲遲無法展開。&lt;/p&gt;
&lt;p&gt;終於，不久前耳聞了另一套 Python 實作的 generator：
&lt;a href="http://getnikola.com/"&gt;Nikola&lt;/a&gt;，照慣例掃了一遍所有的 theme，終於看到一個讓我眼睛為之一亮的
theme: &lt;a href="http://www.damian.oquanta.info/posts/nikolas-zen-theme-finally-released.html"&gt;zen&lt;/a&gt;，也就是各位現在正在看著的 theme 了。
終於呀，原來相比起 generator 的功能，我真正需要的只是一個好看的 theme。 :)&lt;/p&gt;
&lt;p&gt;接下來就展示一下 Nikola 在數學公式和 code 的寫法以及其顯示在網頁上的效果吧。&lt;/p&gt;
&lt;h3&gt;Math&lt;/h3&gt;
&lt;p&gt;顯示數學公式其實就只是使用了 &lt;a href="http://www.mathjax.org/"&gt;MathJax&lt;/a&gt;，沒有什麼特別的地方。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;inline math: $e^{ix} = \cos x + i\sin x$&lt;/p&gt;
&lt;p&gt;對應的寫法: &lt;code&gt;$e^{ix} = \cos x + i\sin x$&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;display math: $$\sqrt{1+\sqrt[^p!]{1+a^2}}$$&lt;/p&gt;
&lt;p&gt;對應的寫法: &lt;code&gt;$$\sqrt{1+\sqrt[^p\!]{1+a^2}}$$&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Syntax Highlight&lt;/h3&gt;
&lt;p&gt;Syntax highlight 則是 &lt;a href="http://pythonhosted.org/Markdown/extensions/code_hilite.html"&gt;CodeHilite&lt;/a&gt; 和 &lt;a href="http://pythonhosted.org/Markdown/extensions/fenced_code_blocks.html"&gt;Fenced Code Blocks&lt;/a&gt; 的功勞。&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;HelloWorld&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello World!"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;對應的寫法：&lt;/p&gt;
&lt;pre&gt;```java
class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
```&lt;/pre&gt;

&lt;h3&gt;CJK-space-fix&lt;/h3&gt;
&lt;p&gt;最後來個置入式行銷介紹一下我自己開發的 &lt;a href="https://github.com/sayuan/CJK-space-fix/"&gt;CJK-space-fix&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;很多人在寫 markdown 或著其他格式的檔案時，會習慣在不超過 column 80 的位置
換行。例如：
&lt;/p&gt;&lt;pre&gt;
很多人在寫 markdown 或著其他格式的檔案時，會習慣在不超過 column 80 的位置
換行。例如：
&lt;/pre&gt;
&lt;p&gt;這在 Python-Markdown 會被處理成如下
&lt;/p&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;很多人在寫 markdown 或著其他格式的檔案時，會習慣在不超過 column 80 的位置
換行。例如：&lt;code&gt;&amp;lt;/p&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然後顯示在瀏覽器上時，就會在 "位置" 和 "換行" 之間有一個多餘的空白，像是這樣：
&lt;/p&gt;&lt;pre&gt;
很多人在寫 markdown 或著其他格式的檔案時，會習慣在不超過 column 80 的位置 換行。例如：
&lt;/pre&gt;
&lt;p&gt;這在許多以空白作為單字分隔的語言中都不是問題，但是在中文卻會顯得很突兀。&lt;/p&gt;
&lt;p&gt;有些人的解決方式是編輯 markdown 時故意不換行；
也有些人是在編輯文章時，故意選在標點符號的位置換行。
當然也有其他人和我一樣用程式解決，但其他人都是在 "markdown 轉 html" 這段
做處理。我一直認為這是屬於瀏覽器的問題，而瀏覽器的問題就該在瀏覽器上被解決，
雖然短時間內各家瀏覽器都不會有解決方案，至少我可以自己寫段 javascript
來處理好這件事，於是這支 script 就誕生了。&lt;/p&gt;
&lt;h3&gt;What's next?&lt;/h3&gt;
&lt;p&gt;老實說，Nikola 也不是個讓我完全滿意的 generator，雖然說是支援
markdown，但找不到針對 markdown 的說明文件，很多功能我也都沒能試出來。
但要是再這樣挑三揀四，我想我大概永遠也沒有辦法開始 blogging 吧。
所以還是就先這樣吧！後續還有很多問題想要處理，像是站內搜尋、轉換至 HTML5、增加適當的 meta 標籤……等等。
不過我想最大的問題應該是我能堅持 blogging 多久吧？&lt;/p&gt;&lt;/div&gt;</description><category>CJK-space-fix</category><category>Markdown</category><category>mathjax</category><category>Nikola</category><category>static blog generator</category><guid>http://sayuan.github.io/posts/finally-my-new-blog.html</guid><pubDate>Wed, 29 Jan 2014 13:05:42 GMT</pubDate></item></channel></rss>