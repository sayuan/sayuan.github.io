<!DOCTYPE html>
<html prefix="
og: http://ogp.me/ns#
article: http://ogp.me/ns/article#
" lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="description" content="Shiao-An Yuan personal blog">
    <meta name="viewport" content="width=device-width">
    <title>SAY something | SAY something</title>

                <link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">

                <link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">

      <link rel="canonical" href="https://sayuan.github.io/index.html">



    
        <!--[if lt IE 9]><script src="/assets/js/html5.js"></script><![endif]-->

    

    
    <style>
    div.input_prompt {
      display: none;
    }
    </style>

</head>
<body>
    <section class="social">
        <ul>
                    <li><a href="#" title="Home"><i class="icon-home"></i></a></li>
            <li><a href="archive.html" title="Archives"><i class="icon-folder-open-alt"></i></a></li>
            <li><a href="categories/index.html" title="Tags"><i class="icon-tags"></i></a></li>
            <li><a href="stories/about-me.html" title="About me"><i class="icon-user"></i></a></li>
            <li><a href="https://twitter.com/shiaoanyuan" title="My Twitter"><i class="icon-twitter"></i></a></li>
            <li><a href="https://github.com/sayuan" title="My Github"><i class="icon-github"></i></a></li>
            <li><a href="https://plus.google.com/111763383423728987624/posts" title="My Google+"><i class="icon-google-plus"></i></a></li>
            <li><a href="https://www.linkedin.com/in/sayuan" title="My LinkedIn"><i class="icon-linkedin"></i></a></li>
            <li><a href="rss.xml" title="RSS"><i class="icon-rss"></i></a></li>

        </ul>
    </section>
    <section class="page-content">
        <div class="content" rel="main">
        <div class="post">
            <h1 class="title"><a href="posts/binary-search.html">程式競賽小技巧 - Binary Search</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2015-06-06T23:33:28+08:00">2015-06-06 23:33</time>
                </div>
                <div class="stats">
                                <a href="posts/binary-search.html#disqus_thread" data-disqus-identifier="cache/posts/binary-search.html">Comments</a>


                </div>
                        <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/algorithm.html" rel="tag">algorithm</a></li>
           <li><a class="tag p-category" href="categories/competitive-programming.html" rel="tag">competitive programming</a></li>
           <li><a class="tag p-category" href="categories/programming-contest.html" rel="tag">programming contest</a></li>
        </ul>
        </div>

            </div>
            <div class="body">
                <div>
<p>最近在 <a href="https://kaif.io">Kaif</a> 開了一個 <a href="https://kaif.io/z/programming-contest">程式競賽</a> 區，打算在上面提一些我在競賽中學到的技巧，
不過既然我有一個很久沒動筆的 Blog，不如就直接寫在這裡，再把連結貼到 Kaif 吧。</p>
<p>Binary Search 在程式競賽中，指的不是用來檢查元素在 sorted list 中位置的方法，
而是一種解題技巧。適用 Binary Search 的題目，通常會有兩個特性：</p>
<ol>
<li>
<p>目的是要求出某個變數 "滿足某個條件" 的最小值，
   且變數超出此值後也都會繼續滿足此條件。</p>
</li>
<li>
<p>無法使用有效率的方法計算出答案，但只要給變數任意的值，
   都能容易的判斷出是否滿足條件。</p>
</li>
</ol>
<p>在針對整數域時，我的 code 會像是這樣：</p>
<pre class="code literal-block"><span class="kt">int</span> <span class="n">lower</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">upper</span> <span class="o">=</span> <span class="mi">1000000</span><span class="o">;</span>                    <span class="c1">// 某個大到一定滿足條件的值</span>
<span class="k">while</span> <span class="o">(</span><span class="n">lower</span> <span class="o">&lt;</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">lower</span><span class="o">+</span><span class="n">upper</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="n">satisfied</span> <span class="o">=</span> <span class="n">check</span><span class="o">(</span><span class="n">mid</span><span class="o">);</span>     <span class="c1">// 將 mid 代入檢查是否滿足</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">satified</span><span class="o">)</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
    <span class="k">else</span> <span class="n">lower</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre>


<p>離開 <code>while</code> 迴圈時，<code>lower</code> 會與 <code>upper</code> 相等，並且就是所求答案。</p>
<p>那麼在實數域會有什麼不同呢？這就是我覺得有意思的地方了。
由於浮點數精確度的關係，是有可能發生 <code>mid</code> 等於 <code>lower</code> 的情況，導致形成無窮迴圈。</p>
<p>好在我們知道比較浮點數應該要允許一點誤差。通常我的習慣是加上一個常數
<code>Є</code>，於是 code 會長這樣：</p>
<pre class="code literal-block"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">EPSILON</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">8</span><span class="o">;</span>

<span class="k">while</span> <span class="o">(</span><span class="n">lower</span><span class="o">+</span><span class="n">EPSILON</span> <span class="o">&lt;</span> <span class="n">upper</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</pre>


<p>使用這個技巧，只要你選擇了 "適當" 的 <code>Є</code>，程式就會是可以正確運行的。
但什麼情況下會出問題呢？</p>
<p>當你的 <code>lower</code> 很大，而 <code>Є</code> 很小時，同樣有可能發生 <code>lower+EPSILON==lower</code> 的情況。</p>
<p>那有沒有更好的方法？看看以下的 code 吧。</p>
<pre class="code literal-block"><span class="kt">double</span> <span class="n">lower</span> <span class="o">=</span> <span class="mf">0.0</span><span class="o">;</span>
<span class="kt">double</span> <span class="n">upper</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e30</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">times</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">times</span><span class="o">&lt;</span><span class="mi">50</span><span class="o">;</span> <span class="n">times</span><span class="o">++)</span> <span class="o">{</span>      <span class="c1">// 注意這行</span>
    <span class="kt">double</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">lower</span><span class="o">+</span><span class="n">upper</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
    <span class="kt">boolean</span> <span class="n">satisfied</span> <span class="o">=</span> <span class="n">check</span><span class="o">(</span><span class="n">mid</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">satisfied</span><span class="o">)</span> <span class="n">upper</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
    <span class="k">else</span> <span class="n">lower</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
<span class="o">}</span>
</pre>


<p>結果就是什麼都不要管，固定跑個足夠次數就好。:p</p>
<p>我自己習慣跑 50 次，但也看過其他參賽者使用 40, 100, 200 次。</p>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/network-topology-by-graphviz.html">使用 Graphviz 繪製網路拓樸</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2014-02-23T22:02:59+08:00">2014-02-23 22:02</time>
                </div>
                <div class="stats">
                                <a href="posts/network-topology-by-graphviz.html#disqus_thread" data-disqus-identifier="cache/posts/network-topology-by-graphviz.html">Comments</a>


                </div>
                        <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/dot.html" rel="tag">Dot</a></li>
           <li><a class="tag p-category" href="categories/graphviz.html" rel="tag">Graphviz</a></li>
           <li><a class="tag p-category" href="categories/network.html" rel="tag">Network</a></li>
        </ul>
        </div>

            </div>
            <div class="body">
                <div>
<p>自從離開了 Android 產業之後，我加入了一間與網路服務相關的新創公司。
在工作內容上，經常會需要理解對方的網路環境，而解決這個問題最好的方法，
就是事先準備好一份網路拓樸並歸檔。</p>
<h3>Requirements</h3>
<p>因此，接下來的任務就是尋找一個適合我們的 Diagram Editor，以下是我們的需求：</p>
<ol>
<li>跨平台：公司內三種作業系統都有人使用，需要選擇一個各種平台上都能使用的檔案
   格式，開放格式尤佳。</li>
<li>簡單：單就繪圖操作的部份，希望是連非技術人員也能夠使用。</li>
<li>容易修改：當網路架構有些微變動時，希望能夠很容易的完成修改，不需要大量的微
   調各節點的位置。</li>
<li>版本控制：不管是使用什麼格式，版本控制都是必要的，但 binary 檔案管理起來總
   是比較麻煩。</li>
</ol>
<p>其實不難看出來，會列出這種需求，我根本就只是想內定 <a href="http://www.graphviz.org/">Graphviz</a> 嘛！確實如此，
但在 <strong>簡單</strong> 這個項目上，Graphviz 卻似乎是最差的選擇，不把這個問題處理好，我看
大概很難順利將 Graphviz 導入公司。</p>
<p>我們暫且先不論 Graphviz 是否足夠簡單，還是先把環境準備好，實際畫張圖來看看。</p>
<h3>Installation</h3>
<p>其實在我進行 <del>survey</del> 內定之前，就已經先透過 Google 找了一遍，出乎意料
的只找到了一篇：<a href="http://itsecworks.com/2012/03/16/networking-topology-with-graphviz/">Network topology with graphviz</a>。</p>
<p>不過有總比沒有好，試著依樣畫葫蘆跑一遍，結果卻是 <code>dot</code> 執行時出現錯誤。查了才知
道，原來 Graphviz 到了版本 2.29 之後 <code>node</code> 才開始支援 <code>image</code> 屬性。但我所使用
的 Ubuntu 12.04 的套件庫中的版本只到 2.26，且一直到 14.04 才開始使用更新的版本。</p>
<p>這種類似的事情遇多了，最簡單的方法就是找個現成的 <code>PPA</code>，通常我會從官方維護的開始
找起，於是：</p>
<pre class="code literal-block">sudo apt-add-repository ppa:gviz-adm/graphviz-dev
</pre>


<p>接著要安裝時，<code>apt</code> 卻又出現錯誤：</p>
<pre class="code literal-block"><span class="n">graphviz</span> <span class="o">:</span> <span class="n">Depends</span><span class="o">:</span> <span class="n">libgraphviz4</span> <span class="o">(&gt;=</span> <span class="mf">2.18</span><span class="o">)</span> <span class="n">but</span> <span class="n">it</span> <span class="k">is</span> <span class="n">not</span> <span class="n">going</span> <span class="n">to</span> <span class="n">be</span> <span class="n">installed</span>
</pre>


<p>好在 <a href="http://askubuntu.com/">Ask Ubuntu</a> 上早有<a href="http://askubuntu.com/questions/196230/how-do-i-install-graphviz-2-29-in-12-04">解答</a>，照著做即可：</p>
<pre class="code literal-block">sudo apt-get update
sudo apt-get remove libcdt4 libpathplan4
sudo apt-get install graphviz
</pre>


<h3>Images</h3>
<p>裝好新版本的 Graphviz 後，還需要用來表示各種節點的圖片，這裡我所選擇的是
<a href="http://www.cisco.com/web/about/ac50/ac47/2.html">Cisco 免費提供的 icons</a>。</p>
<p>Cisco 提供的圖片格式是 <code>JPEG</code>，而根據 Graphviz 的文件，應該是有支援 <code>JPEG</code>，
但不知道是哪裡出了問題，我並沒有辦法順利使用，所以我是自行轉成 <code>PNG</code>。</p>
<h3>Results</h3>
<p>最後的結果就是下圖：</p>
<p><img alt="Topology" src="galleries/misc/topology.png"></p>
<p>而上圖對應的 dot 原始檔如下：</p>
<pre class="code literal-block">graph G {
    node [shape=none, height=1.2]
    rankdir=LR

    // Modems
    node [labelloc="b", image="icons/modem.png"] {
        "Modem 1"
        "Modem 2"
    }

    // Routers
    node [labelloc="b", image="icons/atm router.png"] {
        "Router"
    }

    // Switches
    node [labelloc="b", image="icons/atm switch.png"] {
        "Switch"
    }

    // Access Points
    node [labelloc="b", image="icons/wireless router.png"] {
        "AP 1"
        "AP 2"
    }

    // Sub-networks
    node [labelloc="c", image="icons/cloud.png"] {
        "WAN"
    }

    // Relationships
    "WAN" -- {"Modem 1", "Modem 2"} {
        {"Modem 1", "Modem 2"} -- "Router" {
            "Router" -- "Switch" {
                "Switch" -- {"AP 1", "AP 2"}
            }
        }
    }
}
</pre>


<p>如果是曾經接觸過 <code>dot</code> 的讀者，或許會覺得我所使用的語法很怪異，因為原始碼中的
那些大括號與縮排，在 <code>dot</code> 語言中其實是完全沒有作用的，我這樣寫的目的，純粹是
想降低使用 Graphviz 繪製網路拓樸的學習難度。以下是我的一些考量：</p>
<ol>
<li>將 <strong>宣告</strong> 與 <strong>建立關聯</strong> 的部份完全區分開，規定關聯一定要寫在最後面。</li>
<li>將節點宣告的概念，由原先的 <strong>修改後續 node 的 default attributes</strong>，
   變成簡單的 <strong>集合中的元素</strong>。</li>
<li>由於我們所需要繪製的網路圖只會是樹狀結構，使用縮排可以更方便閱讀。</li>
</ol>
<h3>Conclusion</h3>
<p>我們實際的使用方式是將網路拓樸紀錄在 Redmine 的 wiki 內，
而<a href="https://github.com/tckz/redmine-wiki_graphviz_plugin">這裡有一個 plugin</a>，能夠直接將 wiki 中的純文字的 dot，在預覽和儲存後直接以
轉換後的圖片顯示，實在是方常方便。</p>
<p>然而使用 Graphviz 有其極限，對於複雜的網路拓樸，或著對美觀極度要求時，使用其他
的軟體搭配仍然有其必要。</p>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/android-java-debugging-2.html">Android Java 層 Debug 工具介紹 (2)</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2014-02-15T02:22:56+08:00">2014-02-15 02:22</time>
                </div>
                <div class="stats">
                                <a href="posts/android-java-debugging-2.html#disqus_thread" data-disqus-identifier="cache/posts/android-java-debug-2.html">Comments</a>


                </div>
                        <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/android.html" rel="tag">Android</a></li>
           <li><a class="tag p-category" href="categories/apktool.html" rel="tag">apktool</a></li>
           <li><a class="tag p-category" href="categories/debugging.html" rel="tag">debugging</a></li>
           <li><a class="tag p-category" href="categories/eclipse.html" rel="tag">Eclipse</a></li>
        </ul>
        </div>

            </div>
            <div class="body">
                <div>
<p>在系列文的<a href="posts/android-java-debugging-1.html">第一篇文章</a>中，我已經介紹過 Log Viewer 與
Profiler，而這次所要介紹的內容則是 Debugger，以及一些 Reverse Engineering 工具。
那麼，就先從 Debugger 開始吧。</p>
<h3>Remote Debugging</h3>
<p>對於 Android App 開發者來說，在 Android 上 debug 是在自然不過的事了。
您只需要準備好專案，點一下 <code>Debug</code> 按鈕，IDE 就自動進入 debug 模式，接著無論是
下中斷點、單步執行，或是查看變數內容……等，一切皆任君差遣，但……</p>
<ol>
<li>如果不是透過 IDE 啟動的程式執行到一半，出現了預期之外的狀況，這時您還能不
   能透過 Debugger 進行 debug 呢？</li>
<li>若是執行的程式沒有建立專案，甚至沒有 Source Code 時，Debugger 還能有所作為嗎？</li>
<li>又或著是系統廠 RD 最想要的功能，能不能對系統 Service 進行 debug？</li>
</ol>
<p>上述三個問題的答案都是 YES，當然其中也會有一些前提必須滿足，像是 debug 的對象必
須具有 debuggable flag，或著手機本身 image 為 Engineer build。在前一篇文章中我也
提過了，不需要太擔心這個條件無法滿足，因為下一個章節就會來解決這件事。:)</p>
<p>我在這裡所要介紹的技巧，其實就和對 App 進行 debug 本質上是一樣的，只不過操作的
過程比較手動一些。我會以 Eclipse 進行以下的示範，但其實使用任何一款支援 Remote
Debugging 的 debugger 皆可，甚至連 Android plugin 都不需要安裝。</p>
<h4>1. Select debug port</h4>
<p><img alt="Select debug port" src="galleries/android-java-debug/debug_port.png" title="caption test"></p>
<p>首先到任何一個看得見這畫面的地方，不管是 Eclipse 內建的 DDMS 也好，或著獨立的
Android Device Monitor 也好，總之只要是這個畫面都好。</p>
<p>對著想要進行 debug 的 process 點一下。在點選之前，最後一欄的文字本來會是 <code>8600</code>
之類，但點選之後就會變成 <code>8600 / 8700</code>。</p>
<p>這些數字是其實是 Port Frowarding 所開在本機的 port，透過這些 port，就可以和手機
內特定 process 對應的 JVM 進行溝通。</p>
<p>在點選之前的 port 是以流水號方式從 8600 開始編號，而只要是被選取的 process
就會額外準備一組 port 8700。因為數字是固定的，因此在後續設定 debugger 時會比較方
便，所以這個步驟其實並不是必要的。</p>
<h4>2. Create debug configure</h4>
<p><img alt="Create debug configure" src="galleries/android-java-debug/debug_config.png"></p>
<p>接下來，在 <code>Debug Configurations</code> 中建立一個新的 <code>Remote Java Application</code>，
右邊的 <code>Project</code> 則視您 debug 的對象選擇，若是沒有對應的專案則請保持空白，
<code>Port</code> 則填上在前一步驟看到的數字。因為所有我打算進行 debug 的 process 都會事先
被我設定好 port 8700，因此我只需要準備一個 Debug Configuration 即可。</p>
<p>最後按下 <code>Debug</code> 按鈕，順利的話就能看到 debugger 成功 attach，可以開始 debug
了！</p>
<h4>3. Start debugging!</h4>
<p>如果您所 debug 的 App 在 Eclipse 中有對應的專案，相信接下來該怎麼做已經不需要
多說明了，開啟想 debug 的 source code、設好中斷點，接著等程式執行到該部份就好。</p>
<p>但如果是沒有專案的 App，因為 IDE 不知道要去哪裡找 source code，就算您自己開好了
對應的程式碼並試圖在上面建立中斷點，也壓根不會有作用。</p>
<p>現在請回到前一張圖，注意到視窗右半邊共有三個分頁，其中第二個分頁 <code>Source</code> 就是我
們要找的答案！</p>
<p><img alt="Add source" src="galleries/android-java-debug/add_source.png"></p>
<p>將所有需要用到的 source code 的 <code>root</code> 都用 <code>File System Directory</code> 加入後，您就
可以正常的建立中斷點，並隨著 debugger 在程式碼間遨遊了。若以 Android Framework
為例，您所需要加入的路徑大概會是 <code>.../android/frameworks/base/core/java</code>。
除此之外我還會移除掉原先的 <code>Default</code>，因為這裡面都是 Java 的 Library，而 Android
裡頭用的則完全是另一套，雖然提供的 API 大同小異，但實作完全不一樣，這樣是沒辦法顯
示正確對應的 source code 的。</p>
<p>若是連 source code 都沒有，其實您還是可以暫停 thread、觀察變數、單步執行，但是這
樣能做甚麼？別急，看完下一個章節就知道了。</p>
<h3>Reverse Engineering</h3>
<h4>dex2jar</h4>
<p><a href="http://code.google.com/p/dex2jar/">dex2jar</a> 是一套將 dalvik bytecode 轉成 java bytecode 的工具，雖然轉換後的檔案
並沒有因此就變得較好讀，但早就有現成的 Java decompiler 可以搭配使用，例如
<a href="http://jd.benow.ca/#jd-gui">JD-GUI</a> 就是一個常見的搭配。</p>
<p>dex2jar 的執行方式非常的簡單，直接吃 apk 即可：</p>
<pre class="code literal-block">dex2jar.sh CtsVerifier.apk
</pre>


<p>產生的檔案是 <code>CtsVerifier_dex2jar.jar</code>，接著用 <code>jd-gui</code> 開啟：</p>
<pre class="code literal-block">jd-gui CtsVerifier_dex2jar.jar
</pre>


<p><img alt="jd-gui" src="galleries/android-java-debug/jd-gui.png"></p>
<p>不過不是每一次都能像上圖這樣順利，經常會遇到 decompile 的結果不正常的狀況。
這時候也許您可以考慮換一套 decompiler 試試，像 <a href="http://varaneckas.com/jad/">JAD</a> 就是另一個常見的選擇。
這幾天我也剛好在 <a href="http://androidcracking.blogspot.tw/2014/02/zerdeis-luyten-worthwhile-jd-gui.html">android cracking</a> 上看到另一套工具 <a href="https://github.com/deathmarine/Luyten/">Luyten</a>，聽說效果比
JD-GUI 更好。</p>
<p>不管如何，遇到需要 reverse engineering 時，先搬 dex2jar 出來，也許就已經足夠了。
但若是遇到應付不了的情形，或許這時候就該呼叫 apktool 了。</p>
<h4>apktool</h4>
<p><a href="https://code.google.com/p/android-apktool/">apktool</a> 是一個 <code>decode</code> / <code>rebuild</code> apk 的工具，將 apk 解開後的目錄結構如下：</p>
<pre class="code literal-block">AndroidManifest.xml
apktool.yml
assets
lib
res
smali
</pre>


<p>前面提了好幾次的 debuggable flag 就在 AndroidManifest.xml 裡，開啟 debuggable
後 rebuild 並安裝至手機內，先前說過的工具就全部都能使用了。</p>
<h5>smali</h5>
<p>接下來請注意到 smali 這個資料夾，這裡存的是利用 <a href="https://code.google.com/p/smali/">smali</a> 這套工具將
dalvik bytecode 反組譯之後的結果。</p>
<p>smali 這名字取得很有趣，是冰島語的 <code>assembler</code>。為什麼選冰島語？因為 <code>dalvik</code>
是冰島的一個鎮的名字。</p>
<p>smali 的語法源自於 <a href="http://jasmin.sourceforge.net/">jasmin</a>，並將指令替換為 Android 上所用的
<a href="http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html">Dalvik opcodes</a>。</p>
<p>關於 smali 細節語法的說明，似乎不適合繼續寫在這篇文章內了，因此我這裡就貼一小段
source code 與實際產生的 smali 做對照，供各位做參考：</p>
<ul>
<li>source code (截取自 CtsVerifier)</li>
</ul>
<pre class="code literal-block">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">TestListItem</span> <span class="n">item</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mRows</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
        <span class="n">notifyDataSetChanged</span><span class="o">();</span>
    <span class="o">}</span>
</pre>


<ul>
<li>smali</li>
</ul>
<pre class="code literal-block"><span class="c"># virtual methods</span>
<span class="k">.method</span> <span class="k">public</span> <span class="nf">add</span><span class="p">(</span><span class="kt">L</span>com/android/cts/verifier/<span class="nc">TestListAdapter$TestListItem</span>;<span class="p">)</span><span class="kt">V</span>    <span class="c"># 回傳值為 void</span>
<span class="k">    .locals</span> <span class="mi">1</span>   <span class="c"># 除了參數以外只有一個變數，即 v0</span>
<span class="k">    .parameter</span> <span class="s">"item"</span>

<span class="k">    .prologue</span>
<span class="k">    .line</span> <span class="mi">37</span>    <span class="c"># 對應的 source code 行號</span>
    iget-object <span class="nb">v0</span><span class="p">,</span> <span class="nb">p0</span><span class="p">,</span> <span class="kt">L</span>com/android/cts/verifier/<span class="nc">ArrayTestListAdapter</span>;<span class="p">-&gt;</span><span class="nv">mRows</span><span class="p">:</span><span class="kt">L</span>java/util/<span class="nc">List</span>;

    invoke-interface <span class="p">{</span><span class="nb">v0</span><span class="p">,</span> <span class="nb">p1</span><span class="p">},</span> <span class="kt">L</span>java/util/<span class="nc">List</span>;<span class="p">-&gt;</span><span class="nf">add</span><span class="p">(</span><span class="kt">L</span>java/lang/<span class="nc">Object</span>;<span class="p">)</span><span class="kt">Z</span>

<span class="k">    .line</span> <span class="mi">38</span>    <span class="c"># p0=this, p1=item</span>
    invoke-virtual <span class="p">{</span><span class="nb">p0</span><span class="p">},</span> <span class="kt">L</span>com/android/cts/verifier/<span class="nc">ArrayTestListAdapter</span>;<span class="p">-&gt;</span><span class="nf">notifyDataSetChanged</span><span class="p">()</span><span class="kt">V</span>

<span class="k">    .line</span> <span class="mi">39</span>
    return-void
<span class="k">.end method</span>
</pre>


<p>smali 的語法其實並不難，因此在理解之後，少量的修改程式邏輯或著安插其他程式碼，
也都不會是什麼困難的事了。</p>
<h3>Conclusion</h3>
<p>這次兩篇文章共介紹了四種類型的工具，說明一下我使用各種工具的時機：</p>
<ul>
<li>Log viewer<ul>
<li>尋找問題發生點</li>
<li>了解流程，除了訊息本身以外，也很容易藉由文字找出對應的程式位置</li>
</ul>
</li>
<li>Profiler<ul>
<li>找出程式瓶頸與需要最佳化的位置</li>
<li>畫 call graph 幫助了解執行流程</li>
</ul>
</li>
<li>Debugger<ul>
<li>觀察各 thread 的 method stack 與變數內容</li>
</ul>
</li>
<li>Reverse Engineering tools<ul>
<li>不得已沒有 source code 的時候才用 XD</li>
</ul>
</li>
</ul>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/android-java-debugging-1.html">Android Java 層 Debug 工具介紹 (1)</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2014-02-09T20:36:56+08:00">2014-02-09 20:36</time>
                </div>
                <div class="stats">
                                <a href="posts/android-java-debugging-1.html#disqus_thread" data-disqus-identifier="cache/posts/android-java-debug-1.html">Comments</a>


                </div>
                        <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/android.html" rel="tag">Android</a></li>
           <li><a class="tag p-category" href="categories/coloredlogcat.html" rel="tag">coloredlogcat</a></li>
           <li><a class="tag p-category" href="categories/debugging.html" rel="tag">debugging</a></li>
           <li><a class="tag p-category" href="categories/traceview.html" rel="tag">traceview</a></li>
        </ul>
        </div>

            </div>
            <div class="body">
                <div>
<p>今天又從硬碟裡翻出一份還在前公司時製作的內訓資料，是當時所有我會的 Android Java
debug 工具的介紹，於是整理之後就成為了現在這篇文章。</p>
<p>本文中提及的工具與使用方法我都已測試過，即使在目前在最新的 Android 4.4
上也還能正常使用，但畢竟這些已經是一年前的資料了，或許已經有更新的工具能替代
使用，因此若是您知道其他更好用的工具，也希望您能不吝指出。:)</p>
<h3>Log Viewer</h3>
<p>老實說我從來就不覺得 <code>ADT</code> 附的 Log Viewer 好用，身為 command line
魔人，當然要選擇 command line 的作法。</p>
<h4>Colored Logcat</h4>
<p>雖然 <code>adb</code> 本身就有 <code>logcat</code> 指令，但既沒有對齊欄位，也沒有顏色識別，實在是
不容易從中識別出自己所關心的 log，好在早就有現成的 <a href="http://jsharkey.org/blog/2009/04/22/modifying-the-android-logcat-stream-for-full-color-debugging/">Colored Logcat</a>。<code>Colored
Logcat</code> 是由 <a href="http://jsharkey.org">Jeff Sharkey</a> 所開發的一個以 python 寫成，用來 parsing <code>adb
logcat</code> 的輸出，並加上顏色與對齊後輸出的工具。</p>
<p><img alt="coloredlogcat" src="galleries/android-java-debug/colorcat.png"></p>
<p>由於原作者釋出 <code>Colored Logcat</code> 之後沒有持續維護，因此在 Github 及 Google Code
上都可以找到其他人的分支。我自己所使用的版本則是對其做了兩個修改：</p>
<ol>
<li>增加 -v 參數使其可顯示每一筆 log 的時間</li>
<li>補上原實作漏了的 log 層級：FATAL</li>
</ol>
<p>或許有人會問，這種工具怎麼看都還是比不上 <code>ADT</code> 內建的 Log Viewer 呀，究竟
command line 有何神奇魔力？這些工具單獨使用的話確實是不怎麼樣，但厲害的地方在於
它們可以很輕鬆的搭配其他 shell 指令而組合出更多彈性的功能，例如：</p>
<ol>
<li>搭配 grep 以過濾關鍵字</li>
<li>將輸出 redirect (或 tee) 至檔案，方便後續處理</li>
<li>如果有使用 screen, tmux，還可以隨時暫停，並在畫面上搜尋關鍵字</li>
</ol>
<h4>Debug function</h4>
<pre class="code literal-block"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">debug</span><span class="o">(</span><span class="n">Object</span><span class="o">...</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">StackTraceElement</span> <span class="n">call</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getStackTrace</span><span class="o">()[</span><span class="mi">3</span><span class="o">];</span>
    <span class="n">String</span> <span class="n">className</span> <span class="o">=</span> <span class="n">call</span><span class="o">.</span><span class="na">getClassName</span><span class="o">();</span>
    <span class="n">className</span> <span class="o">=</span> <span class="n">className</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">className</span><span class="o">.</span><span class="na">lastIndexOf</span><span class="o">(</span><span class="sc">'.'</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="n">android</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="s">"_DEBUG_"</span><span class="o">,</span> <span class="n">call</span><span class="o">.</span><span class="na">getLineNumber</span><span class="o">()</span> <span class="o">+</span> <span class="s">": "</span>
            <span class="o">+</span> <span class="n">className</span> <span class="o">+</span> <span class="s">"."</span> <span class="o">+</span> <span class="n">call</span><span class="o">.</span><span class="na">getMethodName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" "</span>
            <span class="o">+</span> <span class="n">java</span><span class="o">.</span><span class="na">util</span><span class="o">.</span><span class="na">Arrays</span><span class="o">.</span><span class="na">deepToString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
<span class="o">}</span>
</pre>


<p>這個其實既不是 Log Viewer，也不能算是 debug tool，勉強只能算是個小技巧吧。
它的功用是在顯示的 log 前面加上 class name, method name 與行數，就像是 C 的
<code>__FILE__</code>, <code>__LINE__</code> 與 <code>__func__</code>。</p>
<p>由於參數 <code>arr</code> 使用了 Java 5.0 開始才有的 <code>Autoboxing</code> 與
<code>Varargs</code>，因此無論是什麼參數、幾個參數都能接受，而輸出的部份又用了
deepToString，所以連陣列內容都能印出。</p>
<p>這個 method 其實不只能在 Android 上使用，一般的 Java
環境下也能運作，但需要將第二行中的常數 <code>3</code> 改為 <code>2</code> 才行。</p>
<h3>Profiler</h3>
<p>接下來這個 profiler 其實只是 <code>ADT</code> 內建的工具，官方也有一篇詳細
的<a href="http://developer.android.com/tools/debugging/debugging-tracing.html">教學</a>，所以我就只以圖片與簡短描述帶過。</p>
<p>執行 profiler 共有兩種方式，第一種方式是在程式中安插程式碼：</p>
<h4>第一種</h4>
<pre class="code literal-block"><span class="c1">// start tracing to "/sdcard/calc.trace"</span>
<span class="n">Debug</span><span class="o">.</span><span class="na">startMethodTracing</span><span class="o">(</span><span class="s">"calc"</span><span class="o">);</span>

<span class="c1">// 做 profiling 的區域</span>

<span class="c1">// stop tracing</span>
<span class="n">Debug</span><span class="o">.</span><span class="na">stopMethodTracing</span><span class="o">();</span>
</pre>


<p>上述這個方法比較麻煩，但能確保 profiling 的對象只有自己關心的區域。</p>
<h4>第二種</h4>
<p><img alt="Start Profiling" src="galleries/android-java-debug/start_profiling.png"></p>
<p>第二個方法則是直接在 Android Device Monitor 工具內，選好要 profiling 的
process，然後點上圖中被藍色圓圈圈起的按鈕，並在打算停止 profiling
時再按一下即可。</p>
<p><img alt="Traceview" src="galleries/android-java-debug/traceview.png"></p>
<p>接著畫面上就會出現 profiling 的結果。</p>
<h4>Call Graph</h4>
<p>第一種方法執行完的 trace file 會存在 SD card 內，而第二種則是存在
<code>/tmp/ddms....</code>，可以從分頁名稱上得到確切的檔名。</p>
<p>有了 trace file，接著只要執行：</p>
<pre class="code literal-block">dmtracedump -g callgraph.png calc.trace
</pre>


<p>就可以得到如下的 call graph。</p>
<p><img alt="Call Graph" src="galleries/android-java-debug/callgraph.png"></p>
<h4>debuggable flag</h4>
<p>第二種方法在使用上有個限制，即操作的手機必須是 Engineering build，或著所觀察的
App 具有 debuggable flag。</p>
<p>不過即使兩像條件都不具備也不用擔心，您還是可以用後續文章將會提到的 reverse
engineering tool: <code>apktool</code>，將原本的 apk 檔解開、加上 debuggable
flag、重新包裝回 apk 檔，然後就能開心的使用了。運用這種重新打包的手法，就算沒有
source code，也能將所需的 code 插入，因此正好可以拿來安插第一種 profiling
所需的 code，細節將會在後續的文章中說明。</p>
<p>篇幅好像差不多了，那麼就先在此打住吧。
接下來預計還會寫一至兩篇文章介紹 remote debugging 與 reverse engineering
tool，希望我能早日完成。:)</p>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/android-cts-report.html">Android CTS - 讓 Report 說話</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2014-02-02T23:37:47+08:00">2014-02-02 23:37</time>
                </div>
                <div class="stats">
                                <a href="posts/android-cts-report.html#disqus_thread" data-disqus-identifier="cache/posts/android-cts-report.html">Comments</a>


                </div>
                        <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/android.html" rel="tag">Android</a></li>
           <li><a class="tag p-category" href="categories/cts.html" rel="tag">CTS</a></li>
        </ul>
        </div>

            </div>
            <div class="body">
                <div>
<p>接著來談談當初在負責 CTS 時遇到的最大困難，以及最後解決的方法。</p>
<h3>什麼是 CTS？</h3>
<p>Android 雖然是 Open Source Project，即任何的廠商都可以自行生產手機，但
如果想在出廠時內建 Google Play 等 Google 所提供的 APP，就必須與 Google
簽合約，即每一款生產的手機都需要通過 CTS 測試。</p>
<p>CTS 測試包含上萬筆測項，能否順利通過將影響手機是否能正式出貨，因此對各系
統廠而言，這都會是一個相當重要的任務。通過 CTS 的方式，是由廠商自行執行
Google 提供的 CTS 程式，並產生一份通過所有測試的 Report，Google 審核無誤
後，這樣就算大功告成了。</p>
<p>然而，即使是同一款手機，每一次執行 CTS 都不見得能得到完全相同的結果。這
部份有可能是手機本身的軟、硬體不穩定，也有可能是來自於 CTS 的 bug。</p>
<h3>困難點</h3>
<p>由於每次執行 CTS 得到的結果都不同，而只要成功產生一次全部通過的 Report
就可以提交，那麼是不是可以準備很多台電腦、很多台手機，每天二十四小時的跑
，只要任何一次 ALL PASS 就好？</p>
<p>是的，這樣確實沒有問題。於是公司安排了一部分的測試人力負責運行 CTS，早期
是一天產出一份，後來不知道怎麼搞的，變成兩組人馬在做，有時候一天會產生近
十份報表。</p>
<p>如果是問題已經被解決的差不多的階段，這樣做確實很合理；但如果有些測試尚未
被解決，百分百會失敗，這樣做就不是很有意義了。而每一份報告送來給我時，通
常還會附上測試者自己的觀察，例如：「某個測試最近失敗的機率好像變高了」、
「同個型號的 A 手機一直失敗、但 B 手機就沒問題」、「晚上再開始跑好像比較
容易成功」。這些猜測有時正確、有時錯誤，然而因為 Report 實在太多，我也實
在沒辦法從中學到什麼。<strong>於是這些數不清的 Report，消耗了大量的人力與資源
，卻什麼忙也沒幫上。</strong></p>
<h3>突破口</h3>
<p>其實不難發覺，關鍵就在這些 Report 上。大部分需要的資訊，這些 Report 上都
有，只是太多了、太零散了，沒有辦法馬上調出我需要的資訊，例如：「X 測項最
近一週的失敗率是否比上週高」、「A 測試者跑 Y 測項時是否比較容易失敗」？</p>
<p>而解決的方法也就更簡單了，我花了三天時間寫了一個網頁，提供一個界面讓測試
者上傳 Report。程式收到 Report 後，就會擷取所有重要資訊，包含手機名稱與
識別碼、測試者的名字、執行時間和所有發生失敗的測試，並將這些資料統統丟進
資料庫。</p>
<p>突然之間，所有的問題都獲得了解答。我們利用這個方式發現各家電信業者在執行
<a href="https://github.com/sayuan/Android-CTS-notes/wiki/android.telephony.cts.SmsManagerTest#wiki-testsendmessages">傳簡訊相關的測試</a>的成功率，從此規定以後都用成功率最高的業者的 SIM 卡
；也發現了某測試者因為操作不正確，所以他所負責的報告經常會有額外的狀況。</p>
<h3>所以，重點是？</h3>
<p>其實重點就是，我要把這支程式的關鍵部份放出來。<a href="https://gist.github.com/sayuan/9d8611179405989d502c">gist 連接在此</a>。</p>
<p>至於為什麼不放整個網站出來？單純只是因為我的前端寫太爛，不好意思放出來讓
大家見笑。事實上，這個網站其實非常的簡單，甚至我放出的部份也沒有任何難度
，只是單純的 parsing XML 並存進資料庫而已，真要說有難度的地方，也只是
parsing 時比較費工而已。所以我放出 parsing 的部份，希望有需要的人可以在
略做修改的情況下就能夠使用，如果在使用上有遭遇什麼困難，也歡迎與我聯繫。</p>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/android-cts.html">Android CTS 筆記</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2014-02-02T19:25:16+08:00">2014-02-02 19:25</time>
                </div>
                <div class="stats">
                                <a href="posts/android-cts.html#disqus_thread" data-disqus-identifier="cache/posts/android-cts.html">Comments</a>


                </div>
                        <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/android.html" rel="tag">Android</a></li>
           <li><a class="tag p-category" href="categories/cts.html" rel="tag">CTS</a></li>
        </ul>
        </div>

            </div>
            <div class="body">
                <div>
<p>我過去曾經在國內的二線 Android 系統廠服務了約一年半的時間，當時所負責的
工作之一，就是負責處理 Android CTS 問題。雖然不是所有的 Issue 都由我負責
到底，但第一關的釐清、分配，和解決最後無明確歸屬的 Issue，都是我的任務。
而這一年多來追蹤過的 CTS 問題少說也有百項，也因此累積了不少的筆記。</p>
<p>2013 年初我離職之後，這些筆記就一直塵封在我的硬碟至今。多虧了最近的年假
，心血來潮花了整整一天的時間，終於有機會讓這些筆記重見天日。我把它們全部
都重寫成 markdown 格式，並且上傳至 Github 的 wiki，連結就在<a href="https://github.com/sayuan/Android-CTS-notes">這裡</a>。</p>
<p>希望這些資訊能給還在和 CTS 奮鬥的工程師們一些幫助，如果其中有任何錯誤與
不足的部份，還請不吝指出或著直接進行修正。</p>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/ydict.html">ydict - node.js 實作</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2014-01-30T15:07:52+08:00">2014-01-30 15:07</time>
                </div>
                <div class="stats">
                                <a href="posts/ydict.html#disqus_thread" data-disqus-identifier="cache/posts/ydict.html">Comments</a>


                </div>
                        <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/nodejs.html" rel="tag">node.js</a></li>
           <li><a class="tag p-category" href="categories/ydict.html" rel="tag">ydict</a></li>
        </ul>
        </div>

            </div>
            <div class="body">
                <div>
<h3>What is "ydict"</h3>
<p>身為一名 command line 魔人，儘可能的將所有在電腦上的操作在 command line
之內完成，是一件理所當然的事情，就連查字典也不例外，而 ydict
就是這樣的工具。</p>
<p><img alt="ydict" src="galleries/misc/ydict.png"></p>
<p>ydict 的資料來自於 <a href="http://tw.dictionary.yahoo.com/">Yahoo 字典</a>，事實上 ydict
所作的事情就只是以使用者的輸入詞在 Yahoo 字典上查詢，然後 parsing
出重要的資訊，並以適合 terminal 的格式顯示在螢幕上。</p>
<p>但其實 ydict 並不是 "一個" 工具，事實上很多人都曾開發自己的實作，
而各實作也有各自的分支，我現在已經找不出最早是由誰開發的了。
在眾多版本之中，我使用了最長時間的是 <a href="https://github.com/freehaha/ydict">freehaha 實作的 Python 版本</a>，
其次則是 <a href="http://fourdollars.blogspot.tw/2008/05/vim-ydict.html">FourDollars 的 Perl 版本</a>，在此先向兩位作者致上感謝。</p>
<h3>My works</h3>
<p>使用 ydict 這工具對我來說已經到了不可或缺的地步，但幾乎每隔一段時間 Yahoo
字典就會改版，而接下來的幾天在作者尚未更新之前，我就會沒有 ydict 可使用。
而另一方面，我也會希望能針對自己的需求，對 ydict 進行修改。</p>
<p>我也確實試過自己動手修改，但後續要繼續與原作者的版本接軌卻反而成了一件麻煩事。
而在先前嘗試修改的經驗裡，我覺得必須要有容易更新的 parsing 規則，才能夠快速的針對
Yahoo 字典的改版做出更新。正巧最近我剛學了一點 JavaScript 與
node.js，我想如果能像 jQuery 一樣使用 CSS selector 進行
parsing，事情也許會簡單很多，於是 <a href="https://github.com/sayuan/ydict.js/">ydict.js</a> 就此誕生。</p>
<p>ydict.js 的一個主要設計考量是，parsing 與 display
必須分離，parsing 的部份只會回傳處理後的 json，而 display 只是單純的將 josn
檔依照格式顯示在螢幕上， 因此在任何一方修改都不會影響到另一方。
另外我也把 parsing 的部份包成 module，讓其他 project
可以直接引用，雖然我覺得這個功能完全只是雞肋。:p</p>
<p>此外，我也已經將 ydict.js 上傳 npm，因此只要執行下述指令即可完成安裝，
希望各位會喜歡。</p>
<pre class="code literal-block">[sudo] npm install -g ydict.js
</pre>


<h3>What else?</h3>
<p>我的好友 Andrew 與 Jeff 也和我一樣依賴 ydict，因此在去年 Yahoo
字典改版，各家實作卻都尚未支援之前，他們也都各自開發了自己的實作。</p>
<p>首先是 <a href="https://github.com/yongjhih/rc/blob/master/bin/andict">Andrew 的 shell script 版</a>，使用 w3m 的超簡短作弊寫法，
麻雀雖小卻是五臟俱全。(<strong>使用前請先安裝 w3m 套件。</strong>)</p>
<p>另外就是 <a href="https://github.com/JeffChien/jydict">Jeff 開發的 LiveScript 版</a>，和 ydict.js 一樣使用 <a href="https://github.com/MatthewMueller/cheerio">cheerio</a>
來處理 parsing，並且同樣也已經上傳 npm，因此只要執行下述指令即可安裝：</p>
<pre class="code literal-block">[sudo] npm install -g jydict
</pre>
</div>
            </div>
        </div>
        <div class="post">
            <h1 class="title"><a href="posts/finally-my-new-blog.html">終於，新居落成</a></h1>
            <div class="meta">
                <div class="authordate">
                    <time class="timeago" datetime="2014-01-29T21:05:42+08:00">2014-01-29 21:05</time>
                </div>
                <div class="stats">
                                <a href="posts/finally-my-new-blog.html#disqus_thread" data-disqus-identifier="cache/posts/finally-my-new-blog.html">Comments</a>


                </div>
                        <div itemprop="keywords" class="tags">
        <ul>
        Tags : 
           <li><a class="tag p-category" href="categories/cjk-space-fix.html" rel="tag">CJK-space-fix</a></li>
           <li><a class="tag p-category" href="categories/markdown.html" rel="tag">Markdown</a></li>
           <li><a class="tag p-category" href="categories/mathjax.html" rel="tag">mathjax</a></li>
           <li><a class="tag p-category" href="categories/nikola.html" rel="tag">Nikola</a></li>
           <li><a class="tag p-category" href="categories/static-blog-generator.html" rel="tag">static blog generator</a></li>
        </ul>
        </div>

            </div>
            <div class="body">
                <div>
<h3>塵埃落定</h3>
<p>嚷著說要寫 blog 也差不多拖了一、兩年了，除了單純的因為我懶以外，找不到合適的
static blog generator 也是一大主因。為了讓 blog
能完全在自己的掌控之中，我必須選一個自己看得懂、改得動的語言所實作的
generator，因此我首先關注的是以 Python 實作的 <a href="http://blog.getpelican.com/">Pelican</a>。</p>
<p>確認了 Pelican 有所有我需要的功能：支援 markdown 語法、能夠顯示 LaTex
語法、syntax highlight 當然也是必要的，還有其他 blog 必備的 tag, RSS, ……等等。
然後最後是，選一個看得順眼的 theme ……。糟糕，怎麼找不到合適的？</p>
<p>我這個人除了懶以外，另一個缺點是龜毛，而且常常是龜毛在我沒有能力做得更好的地方。
我開始嘗試改寫 theme，當然沒有美術細胞的我，即使投入了不少時間，
卻仍然做不出能看的東西，間接導致我的部落格生涯遲遲無法展開。</p>
<p>終於，不久前耳聞了另一套 Python 實作的 generator：
<a href="http://getnikola.com/">Nikola</a>，照慣例掃了一遍所有的 theme，終於看到一個讓我眼睛為之一亮的
theme: <a href="http://www.damian.oquanta.info/posts/nikolas-zen-theme-finally-released.html">zen</a>，也就是各位現在正在看著的 theme 了。
終於呀，原來相比起 generator 的功能，我真正需要的只是一個好看的 theme。 :)</p>
<p>接下來就展示一下 Nikola 在數學公式和 code 的寫法以及其顯示在網頁上的效果吧。</p>
<h3>Math</h3>
<p>顯示數學公式其實就只是使用了 <a href="http://www.mathjax.org/">MathJax</a>，沒有什麼特別的地方。</p>
<ul>
<li>
<p>inline mathematics: \(e^{ix} = \cos x + i\sin x\)</p>
<p>對應的寫法: <code>\\(e^{ix} = \cos x + i\sin x\\)</code></p>
</li>
<li>
<p>display mathematics: \[\sqrt{1+\sqrt[^p!]{1+a^2}}\]</p>
<p>對應的寫法: <code>\\[\sqrt{1+\sqrt[^p\!]{1+a^2}}\\]</code></p>
</li>
</ul>
<h3>Syntax Highlight</h3>
<p>Syntax highlight 則是 <a href="http://pythonhosted.org/Markdown/extensions/code_hilite.html">CodeHilite</a> 和 <a href="http://pythonhosted.org/Markdown/extensions/fenced_code_blocks.html">Fenced Code Blocks</a> 的功勞。</p>
<pre class="code literal-block"><span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Hello World!"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre>


<p>對應的寫法：</p>
<pre>```java
class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
```</pre>

<h3>CJK-space-fix</h3>
<p>最後來個置入式行銷介紹一下我自己開發的 <a href="https://github.com/sayuan/CJK-space-fix/">CJK-space-fix</a>。</p>
<p>很多人在寫 markdown 或著其他格式的檔案時，會習慣在不超過 column 80 的位置
換行。例如：
</p>
<pre>
很多人在寫 markdown 或著其他格式的檔案時，會習慣在不超過 column 80 的位置
換行。例如：
</pre>
<p>這在 Python-Markdown 會被處理成如下
</p>
<pre>
<code>&lt;p&gt;</code>很多人在寫 markdown 或著其他格式的檔案時，會習慣在不超過 column 80 的位置
換行。例如：<code>&lt;/p&gt;</code>
</pre>
<p>然後顯示在瀏覽器上時，就會在 "位置" 和 "換行" 之間有一個多餘的空白，像是這樣：
</p>
<pre>
很多人在寫 markdown 或著其他格式的檔案時，會習慣在不超過 column 80 的位置 換行。例如：
</pre>
<p>這在許多以空白作為單字分隔的語言中都不是問題，但是在中文卻會顯得很突兀。</p>
<p>有些人的解決方式是編輯 markdown 時故意不換行；
也有些人是在編輯文章時，故意選在標點符號的位置換行。
當然也有其他人和我一樣用程式解決，但其他人都是在 "markdown 轉 html" 這段
做處理。我一直認為這是屬於瀏覽器的問題，而瀏覽器的問題就該在瀏覽器上被解決，
雖然短時間內各家瀏覽器都不會有解決方案，至少我可以自己寫段 javascript
來處理好這件事，於是這支 script 就誕生了。</p>
<h3>What's next?</h3>
<p>老實說，Nikola 也不是個讓我完全滿意的 generator，雖然說是支援
markdown，但找不到針對 markdown 的說明文件，很多功能我也都沒能試出來。
但要是再這樣挑三揀四，我想我大概永遠也沒有辦法開始 blogging 吧。
所以還是就先這樣吧！後續還有很多問題想要處理，像是站內搜尋、轉換至 HTML5、增加適當的 meta 標籤……等等。
不過我想最大的問題應該是我能堅持 blogging 多久吧？</p>
</div>
            </div>
        </div>
    
                   <script>var disqus_shortname="say-something";(function(){var a=document.createElement("script");a.async=true;a.src="//"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>


                    <footer id="footer" role="contentinfo">
            <p>Contents © 2015         <a href="mailto:shiao.an.yuan@gmail.com">Shiao-An Yuan</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">
<img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a><br>
This work is licensed under a
<a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/deed.en_US">
Creative Commons Attribution-ShareAlike 4.0 International License
</a>.</p>
            
        </footer>

        </div>
    </section>
    
<script type="text/javascript" src="assets/js/cjk_space_fix.js"></script>
<script type="text/javascript">
  cjkSpaceFix();

  // Google Analytics
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-47613541-1', 'sayuan.github.io');
  ga('send', 'pageview');
</script>

    
                <script src="assets/js/all-nocdn.js" type="text/javascript"></script>
    

        <script type="text/javascript">
            $(function(){
                $('.timeago').timeago();
            });
        </script>
</body>
</html>
